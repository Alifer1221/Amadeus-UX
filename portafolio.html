<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amadeus Hero - Radio Ajustado</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&family=Montserrat:wght@400&display=swap"
        rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #151515;
        }

        #amadeus-hero-section {
            position: relative;
            width: 100%;
            height: 100vh;
            background-color: #151515;
            overflow: hidden;
            font-family: 'Manrope', sans-serif;
            cursor: default;
            z-index: 20;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #amadeus-text-overlay {
            position: absolute;
            top: 50%;
            left: 8%;
            transform: translateY(-50%);
            width: 45%;
            max-width: 650px;
            z-index: 10;
            padding: 2rem;
            pointer-events: none;
        }

        .amadeus-title {
            font-family: 'Manrope', sans-serif;
            font-size: 4.5rem;
            font-weight: 400;
            margin: 0 0 1.5rem 0;
            line-height: 1;
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #6a11cb;
            letter-spacing: -1.5px;
            opacity: 0;
        }

        .amadeus-desc {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.2rem;
            color: #e0e0e0;
            line-height: 1.6;
            margin: 0;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .amadeus-desc.visible {
            opacity: 1;
        }

        .typing-cursor::after {
            content: '|';
            display: inline-block;
            margin-left: 5px;
            color: #2575fc;
            animation: blink 0.8s infinite;
        }

        @media (max-width: 900px) {
            #amadeus-text-overlay {
                position: relative;
                top: 0;
                left: 0;
                transform: none;
                width: 90%;
                margin: 0 auto;
                padding-top: 4rem;
                text-align: center;
            }

            .amadeus-title {
                font-size: 3rem;
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <section id="amadeus-hero-section">
        <div id="amadeus-text-overlay">
            <h2 class="amadeus-title" id="amadeusTitle"></h2>
            <p class="amadeus-desc" id="amadeusPara">
                Más que páginas web: descubre nuestro ecosistema de productos digitales, tanto los lanzados como los que
                están en proceso de creación.
            </p>
        </div>
    </section>

    <script>
        (function () {
            const CONFIG = {
                imageUrl: 'https://raw.githubusercontent.com/Alifer1221/isotipo/main/isotipooooo.png',
                particleSize: 1.8,
                gap: 3,

                // === AJUSTE DE TAMAÑO DEL CIRCULO ===
                mouseRadius: 35, // Antes 70. Ahora es pequeño y preciso.
                mouseForce: 2.0, // Fuerza ajustada para el nuevo tamaño

                duration: 3.5,
                typingSpeed: 100
            };

            const container = document.getElementById('amadeus-hero-section');
            const titleEl = document.getElementById('amadeusTitle');
            const descEl = document.getElementById('amadeusPara');

            let scene, camera, renderer, particles, geometry;
            let count = 0;
            let initialPositions, speeds, offsets, velocitiesX, velocitiesY;
            let mouse = { x: -9999, y: -9999 };
            let width, height;

            const clock = new THREE.Clock();
            let elapsedTime = 0;

            init();

            function init() {
                width = container.offsetWidth;
                height = container.offsetHeight;
                scene = new THREE.Scene();
                camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
                camera.position.z = 10;

                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                const loader = new THREE.TextureLoader();
                loader.crossOrigin = "Anonymous";
                loader.load(CONFIG.imageUrl, function (texture) {
                    createParticles(texture.image);
                    startTextImmediate();
                    animate();
                });

                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('mousemove', onMouseMove, false);
            }

            function createParticles(image) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;

                const aspectRatio = image.width / image.height;
                let logoH = height * 0.75;
                let logoW = logoH * aspectRatio;
                if (logoW > width * 0.6) { logoW = width * 0.6; logoH = logoW / aspectRatio; }

                const startX = (width * 0.75 - logoW / 2);
                const startY = (height - logoH) / 2;

                ctx.drawImage(image, startX, startY, logoW, logoH);
                const data = ctx.getImageData(0, 0, width, height).data;

                const positions = [], colors = [], inits = [], spds = [], offs = [];
                const velsX = [], velsY = [];

                for (let y = 0; y < height; y += CONFIG.gap) {
                    for (let x = 0; x < width; x += CONFIG.gap) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 100) {
                            const pX = x - width / 2;
                            const pY = -(y - height / 2);
                            const ox = (Math.random() - 0.5) * width * 3;
                            const oy = (Math.random() - 0.5) * height * 3;

                            positions.push(ox, oy, 0);
                            inits.push(pX, pY, 0);
                            colors.push(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);
                            spds.push(Math.random() * 0.02 + 0.01);
                            offs.push(Math.random() * Math.PI * 2);
                            velsX.push(0);
                            velsY.push(0);
                        }
                    }
                }

                count = positions.length / 3;
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                initialPositions = new Float32Array(inits);
                speeds = new Float32Array(spds);
                offsets = new Float32Array(offs);
                velocitiesX = new Float32Array(velsX);
                velocitiesY = new Float32Array(velsY);

                particles = new THREE.Points(geometry, new THREE.PointsMaterial({
                    size: CONFIG.particleSize, vertexColors: true, sizeAttenuation: false, transparent: true, opacity: 1
                }));
                scene.add(particles);
            }

            function onMouseMove(event) {
                mouse.x = event.clientX - width / 2;
                mouse.y = -(event.clientY - height / 2);
            }

            function onWindowResize() {
                width = container.offsetWidth;
                height = container.offsetHeight;
                camera.left = width / -2; camera.right = width / 2; camera.top = height / 2; camera.bottom = height / -2;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }

            function startTextImmediate() {
                const text = "Portafolio";
                titleEl.style.opacity = 1;
                titleEl.classList.add('typing-cursor');
                let i = 0;
                const interval = setInterval(() => {
                    titleEl.textContent += text.charAt(i);
                    i++;
                    if (i >= text.length) {
                        clearInterval(interval);
                        titleEl.classList.remove('typing-cursor');
                        descEl.classList.add('visible');
                    }
                }, CONFIG.typingSpeed);
            }

            const easeOut = t => 1 - Math.pow(1 - t, 3);
            let introFinished = false;

            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta();
                elapsedTime += delta;

                let progress = Math.min(elapsedTime / CONFIG.duration, 1.0);

                if (progress >= 1) introFinished = true;
                if (!particles) return;

                const posArray = geometry.attributes.position.array;
                const ease = easeOut(progress);

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;

                    let currentX = posArray[i3];
                    let currentY = posArray[i3 + 1];

                    const homeX = initialPositions[i3] + Math.cos(elapsedTime + offsets[i]) * 2.5;
                    const homeY = initialPositions[i3 + 1] + Math.sin(elapsedTime + offsets[i]) * 2.5;

                    if (!introFinished) {
                        currentX += (homeX - currentX) * 0.02 * ease;
                        currentY += (homeY - currentY) * 0.02 * ease;
                        velocitiesX[i] = 0;
                        velocitiesY[i] = 0;
                    }
                    else {
                        // 1. Resorte
                        const springForceX = (homeX - currentX) * 0.015;
                        const springForceY = (homeY - currentY) * 0.015;

                        velocitiesX[i] += springForceX;
                        velocitiesY[i] += springForceY;

                        // 2. Repulsión Mouse
                        const dx = mouse.x - currentX;
                        const dy = mouse.y - currentY;
                        const distSq = dx * dx + dy * dy;
                        const radiusSq = CONFIG.mouseRadius * CONFIG.mouseRadius;

                        if (distSq < radiusSq) {
                            const dist = Math.sqrt(distSq);
                            let force = (CONFIG.mouseRadius - dist) / CONFIG.mouseRadius;
                            const angle = Math.atan2(dy, dx);

                            velocitiesX[i] -= Math.cos(angle) * force * CONFIG.mouseForce;
                            velocitiesY[i] -= Math.sin(angle) * force * CONFIG.mouseForce;
                        }

                        // 3. Fricción (Viscosidad)
                        velocitiesX[i] *= 0.94;
                        velocitiesY[i] *= 0.94;

                        currentX += velocitiesX[i];
                        currentY += velocitiesY[i];
                    }

                    posArray[i3] = currentX;
                    posArray[i3 + 1] = currentY;
                }

                geometry.attributes.position.needsUpdate = true;
                renderer.render(scene, camera);
            }
        })();
    </script>
</body>

</html>