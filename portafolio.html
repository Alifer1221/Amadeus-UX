<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amadeus Hero - Final WebGL (Fluido)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&family=Montserrat:wght@400&display=swap"
        rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #151515;
        }

        #amadeus-hero-section {
            position: relative;
            width: 100%;
            height: 100vh;
            background-color: #151515;
            overflow: hidden;
            font-family: 'Manrope', sans-serif;
            cursor: default;
            z-index: 20;
        }

        /* Canvas generado por Three.js */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #amadeus-text-overlay {
            position: absolute;
            top: 50%;
            left: 8%;
            transform: translateY(-50%);
            width: 45%;
            max-width: 650px;
            z-index: 10;
            padding: 2rem;
            pointer-events: none;
        }

        .amadeus-title {
            font-family: 'Manrope', sans-serif;
            font-size: 4.5rem;
            font-weight: 400;
            margin: 0 0 1.5rem 0;
            line-height: 1;
            background: linear-gradient(90deg, #6a11cb 0%, #2575fc 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #6a11cb;
            letter-spacing: -1.5px;
            opacity: 0;
        }

        .amadeus-desc {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.2rem;
            color: #e0e0e0;
            line-height: 1.6;
            margin: 0;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .amadeus-desc.visible {
            opacity: 1;
        }

        .typing-cursor::after {
            content: '|';
            display: inline-block;
            margin-left: 5px;
            color: #2575fc;
            animation: blink 0.8s infinite;
        }

        @media (max-width: 900px) {
            #amadeus-text-overlay {
                position: relative;
                top: 0;
                left: 0;
                transform: none;
                width: 90%;
                margin: 0 auto;
                padding-top: 4rem;
                text-align: center;
            }

            .amadeus-title {
                font-size: 3rem;
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <section id="amadeus-hero-section">
        <div id="amadeus-text-overlay">
            <h2 class="amadeus-title" id="amadeusTitle"></h2>
            <p class="amadeus-desc" id="amadeusPara">
                Más que páginas web: descubre nuestro ecosistema de productos digitales, tanto los lanzados como los que
                están en proceso de creación.
            </p>
        </div>
    </section>

    <script>
        (function () {
            // === CONFIGURACIÓN AJUSTADA ===
            const CONFIG = {
                imageUrl: 'https://raw.githubusercontent.com/Alifer1221/isotipo/main/isotipooooo.png',
                particleSize: 1.8,     // Tamaño fino y elegante
                gap: 3,                // Densidad Alta (Calidad original)
                mouseRadius: 60,       // Radio de interacción ajustado
                mouseForce: 40         // Fuerza suave (no explosiva)
            };

            const container = document.getElementById('amadeus-hero-section');
            const titleEl = document.getElementById('amadeusTitle');
            const descEl = document.getElementById('amadeusPara');

            let scene, camera, renderer;
            let geometry, particles;
            let count = 0;

            // Datos físicos
            let initialPositions;
            let speeds, offsets;

            // Mouse fuera de pantalla por defecto
            let mouse = { x: -9999, y: -9999 };
            let width, height;

            init();

            function init() {
                width = container.offsetWidth;
                height = container.offsetHeight;

                // 1. ESCENA
                scene = new THREE.Scene();

                // Cámara Ortográfica (2D real)
                camera = new THREE.OrthographicCamera(
                    width / -2, width / 2,
                    height / 2, height / -2,
                    1, 1000
                );
                camera.position.z = 10;

                // 2. RENDERER
                renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias: true
                });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // 3. CARGAR IMAGEN
                const loader = new THREE.TextureLoader();
                loader.crossOrigin = "Anonymous";
                loader.load(CONFIG.imageUrl, function (texture) {
                    createParticles(texture.image);
                    setupText();
                    animate();
                });

                // Eventos
                window.addEventListener('resize', onWindowResize, false);
                document.addEventListener('mousemove', onMouseMove, false);
            }

            function createParticles(image) {
                // Canvas temporal para leer pixeles
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;

                // Lógica de posición (Derecha Centrada)
                const aspectRatio = image.width / image.height;
                let logoH = height * 0.75;
                let logoW = logoH * aspectRatio;
                if (logoW > width * 0.6) { logoW = width * 0.6; logoH = logoW / aspectRatio; }

                const startX = (width * 0.75 - logoW / 2);
                const startY = (height - logoH) / 2;

                ctx.drawImage(image, startX, startY, logoW, logoH);

                const imgData = ctx.getImageData(0, 0, width, height);
                const data = imgData.data;

                const positions = [];
                const colors = [];
                const inits = [];
                const spds = [];
                const offs = [];

                for (let y = 0; y < height; y += CONFIG.gap) {
                    for (let x = 0; x < width; x += CONFIG.gap) {
                        const i = (y * width + x) * 4;
                        if (data[i + 3] > 100) { // Umbral alfa
                            // Convertir a coordenadas Three.js (0,0 en el centro)
                            const pX = x - width / 2;
                            const pY = -(y - height / 2); // Invertir Y

                            // Origen explosivo
                            const ox = (Math.random() - 0.5) * width * 2;
                            const oy = (Math.random() - 0.5) * height * 2;

                            positions.push(ox, oy, 0);
                            inits.push(pX, pY, 0); // Guardar posición final
                            colors.push(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);

                            spds.push(Math.random() * 0.02 + 0.01);
                            offs.push(Math.random() * Math.PI * 2);
                        }
                    }
                }

                count = positions.length / 3;

                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                initialPositions = new Float32Array(inits);
                speeds = new Float32Array(spds);
                offsets = new Float32Array(offs);

                const material = new THREE.PointsMaterial({
                    size: CONFIG.particleSize,
                    vertexColors: true,
                    sizeAttenuation: false,
                    transparent: true,
                    opacity: 1
                });

                particles = new THREE.Points(geometry, material);
                scene.add(particles);
            }

            function onMouseMove(event) {
                // Mapear mouse a coordenadas del centro (Three.js)
                mouse.x = event.clientX - width / 2;
                mouse.y = -(event.clientY - height / 2);
            }

            function onWindowResize() {
                width = container.offsetWidth;
                height = container.offsetHeight;

                camera.left = width / -2;
                camera.right = width / 2;
                camera.top = height / 2;
                camera.bottom = height / -2;
                camera.updateProjectionMatrix();

                renderer.setSize(width, height);
            }

            let time = 0;
            const easeOut = t => 1 - Math.pow(1 - t, 3);
            let introFinished = false;

            function animate() {
                requestAnimationFrame(animate);

                time += 0.015;
                let progress = Math.min(time / 2.0, 1.0);

                if (progress >= 1) introFinished = true;

                if (!particles) return;

                const posAttribute = geometry.attributes.position;
                const posArray = posAttribute.array;

                const ease = easeOut(progress);

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;

                    // Posición base flotante
                    const homeX = initialPositions[i3];
                    const homeY = initialPositions[i3 + 1];

                    const floatX = homeX + Math.cos(time + offsets[i]) * 2.5;
                    const floatY = homeY + Math.sin(time + offsets[i]) * 2.5;

                    let targetX = floatX;
                    let targetY = floatY;

                    // --- REGLA DE REPULSIÓN CORREGIDA (Suave) ---
                    if (introFinished) {
                        // Distancia al mouse
                        const dx = mouse.x - targetX;
                        const dy = mouse.y - targetY;
                        const distSq = dx * dx + dy * dy;
                        const radiusSq = CONFIG.mouseRadius * CONFIG.mouseRadius;

                        if (distSq < radiusSq) {
                            const dist = Math.sqrt(distSq);
                            // Fuerza no lineal (más fuerte en el centro, suave en bordes)
                            let force = (CONFIG.mouseRadius - dist) / CONFIG.mouseRadius;

                            // Ángulo de empuje
                            const angle = Math.atan2(dy, dx);

                            // Empujar el "Objetivo" (Target) hacia afuera, no la posición actual
                            // Esto crea el efecto elástico
                            const push = force * CONFIG.mouseForce;

                            targetX -= Math.cos(angle) * push;
                            targetY -= Math.sin(angle) * push;
                        }
                    }

                    // --- MOVIMIENTO (LERP) ---
                    // Movemos la partícula desde donde esté hacia su objetivo calculado
                    // Esto suaviza todo movimiento, tanto la intro como el mouse

                    if (!introFinished) {
                        // Intro desde explosión
                        posArray[i3] = posArray[i3] + (targetX - posArray[i3]) * 0.05 * ease;
                        posArray[i3 + 1] = posArray[i3 + 1] + (targetY - posArray[i3 + 1]) * 0.05 * ease;
                    } else {
                        // Física normal (rápida respuesta elástica)
                        posArray[i3] += (targetX - posArray[i3]) * 0.1;
                        posArray[i3 + 1] += (targetY - posArray[i3 + 1]) * 0.1;
                    }
                }

                posAttribute.needsUpdate = true;
                renderer.render(scene, camera);
            }

            function setupText() {
                const text = "Portafolio";
                const typingSpeed = 100;
                let i = 0;
                titleEl.style.opacity = 1;
                titleEl.classList.add('typing-cursor');

                setTimeout(() => {
                    const interval = setInterval(() => {
                        titleEl.textContent += text.charAt(i);
                        i++;
                        if (i >= text.length) {
                            clearInterval(interval);
                            titleEl.classList.remove('typing-cursor');
                            descEl.classList.add('visible');
                        }
                    }, typingSpeed);
                }, 1500);
            }

        })();
    </script>
</body>

</html>